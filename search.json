[{"title":"关于网络请求的一些问题","url":"/2019/06/02/request-issues/","content":"### 请求接口返回状态码0\n原因：请求头中包含不被允许的头部。\n","tags":["javascript"]},{"title":"一些做法及其依据","url":"/2019/05/07/some-practices-and-their-basis/","content":"### 关于 Git 提交格式、为什么要首字母大写、为什么不要混用多种语言等\n\n参考依据：\nhttps://github.com/RomuloOliveira/commit-messages-guide\n\n参考理由：\n- 文章列出了具体的灵感来源和依据，不只是凭个人经验\n- 作者来自知名企业\n- star数高","tags":["javascript"]},{"title":"保存数据并下载文件","url":"/2019/05/07/save-data-as-file/","content":"方法实现：\n```js\nfunction downloadAsFile(data, filename) {\n  const href = window.URL.createObjectURL(new Blob([data]));\n  const downloadElement = document.createElement('a');\n\n  downloadElement.href = href;\n  downloadElement.download = filename;\n  downloadElement.click();\n  window.URL.revokeObjectURL(href);\n}\n```","tags":["javascript","html"]},{"title":"typeof和toString的差别","url":"/2019/05/05/typeof-and-toString/","content":"以下参考`jerryscript`项目中关于 **ecma** 的实现：\n\n`typeof`是直接判断值类型(位于`jerry-core/vm/opcodes.c`)：\n```c\n/**\n * 'typeof' opcode handler.\n *\n * See also: ECMA-262 v5, 11.4.3\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value\n */\necma_value_t\nopfunc_typeof (ecma_value_t left_value) /**< left value */\n{\n  ecma_value_t ret_value = ecma_make_simple_value (ECMA_SIMPLE_VALUE_EMPTY);\n\n  ecma_string_t *type_str_p = NULL;\n\n  if (ecma_is_value_undefined (left_value))\n  {\n    type_str_p = ecma_get_magic_string (LIT_MAGIC_STRING_UNDEFINED);\n  }\n  else if (ecma_is_value_null (left_value))\n  {\n    type_str_p = ecma_get_magic_string (LIT_MAGIC_STRING_OBJECT);\n  }\n  else if (ecma_is_value_boolean (left_value))\n  {\n    type_str_p = ecma_get_magic_string (LIT_MAGIC_STRING_BOOLEAN);\n  }\n  else if (ecma_is_value_number (left_value))\n  {\n    type_str_p = ecma_get_magic_string (LIT_MAGIC_STRING_NUMBER);\n  }\n  else if (ecma_is_value_string (left_value))\n  {\n    type_str_p = ecma_get_magic_string (LIT_MAGIC_STRING_STRING);\n  }\n  else\n  {\n    JERRY_ASSERT (ecma_is_value_object (left_value));\n\n    if (ecma_op_is_callable (left_value))\n    {\n      type_str_p = ecma_get_magic_string (LIT_MAGIC_STRING_FUNCTION);\n    }\n    else\n    {\n      type_str_p = ecma_get_magic_string (LIT_MAGIC_STRING_OBJECT);\n    }\n  }\n\n  ret_value = ecma_make_string_value (type_str_p);\n\n  return ret_value;\n} /* opfunc_typeof */\n```\n而Object.prototype.toString是泛型方法，只判断类类型(位于`jerry-core/emca/builtin-objects/ecma-builtin-object-prototype.c`)：\n```c\n/**\n * The Object.prototype object's 'toString' routine\n *\n * See also:\n *          ECMA-262 v5, 15.2.4.2\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\nstatic ecma_value_t\necma_builtin_object_prototype_object_to_string (ecma_value_t this_arg) /**< this argument */\n{\n  return ecma_builtin_helper_object_to_string (this_arg);\n} /* ecma_builtin_object_prototype_object_to_string */\n```\n\n```c\n/** \\addtogroup ecma ECMA\n * @{\n *\n * \\addtogroup ecmabuiltinhelpers ECMA builtin helper operations\n * @{\n */\n\n/**\n * Common implementation of the Object.prototype.toString routine\n *\n * See also:\n *          ECMA-262 v5, 15.2.4.2\n *\n * Used by:\n *         - The Object.prototype.toString routine.\n *         - The Array.prototype.toString routine as fallback.\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\n\necma_value_t\necma_builtin_helper_object_to_string (const ecma_value_t this_arg) /**< this argument */\n{\n  lit_magic_string_id_t type_string;\n\n  if (ecma_is_value_undefined (this_arg))\n  {\n    type_string = LIT_MAGIC_STRING_UNDEFINED_UL;\n  }\n  else if (ecma_is_value_null (this_arg))\n  {\n    type_string = LIT_MAGIC_STRING_NULL_UL;\n  }\n  else\n  {\n    ecma_value_t obj_this = ecma_op_to_object (this_arg);\n\n    if (ECMA_IS_VALUE_ERROR (obj_this))\n    {\n      return obj_this;\n    }\n\n    JERRY_ASSERT (ecma_is_value_object (obj_this));\n\n    ecma_object_t *obj_p = ecma_get_object_from_value (obj_this);\n\n    type_string = ecma_object_get_class_name (obj_p);\n\n    ecma_free_value (obj_this);\n  }\n\n  ecma_string_t *ret_string_p;\n\n  /* Building string \"[object #type#]\" where type is 'Undefined',\n     'Null' or one of possible object's classes.\n     The string with null character is maximum 27 characters long. */\n  const lit_utf8_size_t buffer_size = 27;\n  lit_utf8_byte_t str_buffer[buffer_size];\n\n  lit_utf8_byte_t *buffer_ptr = str_buffer;\n\n  const lit_magic_string_id_t magic_string_ids[] =\n  {\n    LIT_MAGIC_STRING_LEFT_SQUARE_CHAR,\n    LIT_MAGIC_STRING_OBJECT,\n    LIT_MAGIC_STRING_SPACE_CHAR,\n    type_string,\n    LIT_MAGIC_STRING_RIGHT_SQUARE_CHAR\n  };\n\n  for (uint32_t i = 0; i < sizeof (magic_string_ids) / sizeof (lit_magic_string_id_t); ++i)\n  {\n    buffer_ptr = lit_copy_magic_string_to_buffer (magic_string_ids[i], buffer_ptr,\n                                                  (lit_utf8_size_t) ((str_buffer + buffer_size) - buffer_ptr));\n    JERRY_ASSERT (buffer_ptr <= str_buffer + buffer_size);\n  }\n\n  ret_string_p = ecma_new_ecma_string_from_utf8 (str_buffer, (lit_utf8_size_t) (buffer_ptr - str_buffer));\n\n  return ecma_make_string_value (ret_string_p);\n} /* ecma_builtin_helper_object_to_string */\n```\n\n```c\nlit_magic_string_id_t\necma_object_get_class_name (ecma_object_t *obj_p) /**< object */\n{\n  ecma_object_type_t type = ecma_get_object_type (obj_p);\n\n  switch (type)\n  {\n    case ECMA_OBJECT_TYPE_ARRAY:\n    {\n      return LIT_MAGIC_STRING_ARRAY_UL;\n    }\n    case ECMA_OBJECT_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n      return ext_object_p->u.class_prop.class_id;\n    }\n    case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n    {\n      ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n      switch (ext_obj_p->u.pseudo_array.type)\n      {\n        case ECMA_PSEUDO_ARRAY_ARGUMENTS:\n        {\n          return LIT_MAGIC_STRING_ARGUMENTS_UL;\n        }\n#ifndef CONFIG_DISABLE_ES2015_TYPEDARRAY_BUILTIN\n        case ECMA_PSEUDO_ARRAY_TYPEDARRAY:\n        case ECMA_PSEUDO_ARRAY_TYPEDARRAY_WITH_INFO:\n        {\n          return ext_obj_p->u.pseudo_array.u1.class_id;\n        }\n#endif /* !CONFIG_DISABLE_ES2015_TYPEDARRAY_BUILTIN */\n        default:\n        {\n          JERRY_UNREACHABLE ();\n        }\n      }\n\n      JERRY_UNREACHABLE ();\n      break;\n    }\n    case ECMA_OBJECT_TYPE_FUNCTION:\n    case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n    {\n      return LIT_MAGIC_STRING_FUNCTION_UL;\n    }\n    default:\n    {\n      JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL);\n\n      if (ecma_get_object_is_builtin (obj_p))\n      {\n        ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n        switch (ext_obj_p->u.built_in.id)\n        {\n#ifndef CONFIG_DISABLE_MATH_BUILTIN\n          case ECMA_BUILTIN_ID_MATH:\n          {\n            return LIT_MAGIC_STRING_MATH_UL;\n          }\n#endif /* !CONFIG_DISABLE_MATH_BUILTIN */\n#ifndef CONFIG_DISABLE_JSON_BUILTIN\n          case ECMA_BUILTIN_ID_JSON:\n          {\n            return LIT_MAGIC_STRING_JSON_U;\n          }\n#endif /* !CONFIG_DISABLE_JSON_BUILTIN */\n#ifndef CONFIG_DISABLE_ERROR_BUILTINS\n          case ECMA_BUILTIN_ID_EVAL_ERROR_PROTOTYPE:\n          case ECMA_BUILTIN_ID_RANGE_ERROR_PROTOTYPE:\n          case ECMA_BUILTIN_ID_REFERENCE_ERROR_PROTOTYPE:\n          case ECMA_BUILTIN_ID_SYNTAX_ERROR_PROTOTYPE:\n          case ECMA_BUILTIN_ID_TYPE_ERROR_PROTOTYPE:\n          case ECMA_BUILTIN_ID_URI_ERROR_PROTOTYPE:\n#endif /* !CONFIG_DISABLE_ERROR_BUILTINS */\n          case ECMA_BUILTIN_ID_ERROR_PROTOTYPE:\n          {\n            return LIT_MAGIC_STRING_ERROR_UL;\n          }\n          default:\n          {\n            JERRY_ASSERT (ecma_object_check_class_name_is_object (obj_p));\n\n            return LIT_MAGIC_STRING_OBJECT_UL;\n          }\n        }\n      }\n      else\n      {\n        return LIT_MAGIC_STRING_OBJECT_UL;\n      }\n    }\n  }\n} /* ecma_object_get_class_name */\n```\n对于其它的具体类型，仍然是判断值，例如：\n```\n/** \\addtogroup ecma ECMA\n * @{\n *\n * \\addtogroup ecmabuiltins\n * @{\n *\n * \\addtogroup booleanprototype ECMA Boolean.prototype object built-in\n * @{\n */\n\n/**\n * The Boolean.prototype object's 'toString' routine\n *\n * See also:\n *          ECMA-262 v5, 15.6.4.2\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\nstatic ecma_value_t\necma_builtin_boolean_prototype_object_to_string (ecma_value_t this_arg) /**< this argument */\n{\n  ecma_value_t ret_value = ecma_make_simple_value (ECMA_SIMPLE_VALUE_EMPTY);\n\n  ECMA_TRY_CATCH (value_of_ret,\n                  ecma_builtin_boolean_prototype_object_value_of (this_arg),\n                  ret_value);\n\n  ecma_string_t *ret_str_p;\n\n  if (ecma_is_value_true (value_of_ret))\n  {\n    ret_str_p = ecma_get_magic_string (LIT_MAGIC_STRING_TRUE);\n  }\n  else\n  {\n    JERRY_ASSERT (ecma_is_value_boolean (value_of_ret));\n\n    ret_str_p = ecma_get_magic_string (LIT_MAGIC_STRING_FALSE);\n  }\n\n  ret_value = ecma_make_string_value (ret_str_p);\n\n  ECMA_FINALIZE (value_of_ret);\n\n  return ret_value;\n} /* ecma_builtin_boolean_prototype_object_to_string */\n```","tags":["javascript"]},{"title":"HTML笔记(一)","url":"/2018/11/09/note-html-1/","content":"### 1. `<iframe>`这类标签有时会遇到无法显示页面的错误，这是由**Content-Security-Policy**造成的。\n","tags":["html","css"]},{"title":"TypeScript相关问题(一)","url":"/2018/10/10/note-ts-issues-1/","content":"### 1. 当代码中导入了第三方库的时候，直接编译文件报错。例如以下目录：\n```bash\n.\n├── demo.ts\n├── node_modules\n├── package.json\n├── tsconfig.json\n└── yarn.lock\n```\n其中`demo.ts`的代码如下：\n```js\nimport { of } from 'rxjs'\n\nof(1, 2, 3).subscribe(x => console.log(x))\n```\n用以下方式运行：\n```bash\npixcai@sierra:~/demo|⇒ ./node_modules/.bin/tsc demo.ts\nnode_modules/rxjs/internal/Observable.d.ts(82,59): error TS2693: 'Promise' only refers to a type,but is being used as a value here.\nnode_modules/rxjs/internal/types.d.ts(35,84): error TS2304: Cannot find name 'Iterable'.\nnode_modules/rxjs/internal/types.d.ts(39,6): error TS2304: Cannot find name 'Symbol'.\n```\n如果**TypeScript**装在全局，即`npx tsc demo.ts`，也是一样。\n\n**问题原因**：`tsconfig.json`没生效。\n\n**解决办法**：`npx tsc -p tsconfig.json`或`npx tsc -p .`或`npx tsc --lib es2015,dom demo.ts`。\n\n### 2. `document.getElementById()`、`document.querySelector()`等函数返回的是`Element`类型，如果要取某些属性，比如：\n```js\nconst target = document.querySelector('.target')\ntarget.style.top = '100px'\n```\n则会报错：\n```bash\nerror TS2339: Property 'style' does not exist on type 'Element'.\n```\n\n**解决办法**：转换为`HTMLElement`类型，`const target = <HTMLElement>document.querySelector('.target')`。\n","tags":["typescript"]},{"title":"关于Set-Cookie无法保存","url":"/2018/09/28/note-set-cookie/","content":"出现这个问题大多是不满足同源策略，即从**www.A.com**向**www.B.com**或从**m.A.com**向**e.A.com**或从**A.com:8080**向**A.com:8086**等等设置**Cookie**，这些情况由于协议或域名或端口不同而被阻止设置。网上很多解决办法，不再赘述。\n\n记一下今天自己遇到的坑：\n\n首先，代码里写着`axios.post('http://192.168.0.86:9000/api/user/login')`，而前端运行在`192.168.0.86:8000`，接口响应头存在**Set-Cookie**，但浏览器无法保存，完全符合预期。\n\n之后，为了能设置**Cookie**，转而用**Nginx**代理，以下是代理配置：\n```\nserver {\n  location ^~ /api/ {\n    proxy_pass http://localhost:9000;\n  }\n}\n```\n但还是无法保存。\n\n本以为路径`/api`走代理了，域就会等同于`http://192.168.0.86:8000`，结果还是`axios`填写的地址。\n\n最后把`axios`里的地址去掉，只保留路径就对了。\n","tags":["http"]},{"title":"Nginx部署单页应用","url":"/2018/09/27/nginx-spa/","content":"**React**或**Vue**应用编译为静态文件后用**Nginx**访问的话，需要给**Nginx**添加以下配置：\n```\nserver {\n  listen      80;\n  server_name localhost;\n\n  root /usr/share/nginx/html;\n\n  location / {\n    try_files $uri $uri/ @router;\n  }\n\n  location ^~ /api/ {\n    proxy_pass http://localhost:8080;\n  }\n\n  location @router {\n      rewrite ^.*$ /index.html break;\n  }\n\n  error_page 500 502 503 504  /50x.html;\n  location = /50x.html {\n    root html;\n  }\n}\n```\n","tags":["nginx","react","vue"]},{"title":"按需加载原理","url":"/2018/09/26/note-plugin-import/","content":"使用**antd**之类的框架经常需要以下配置用于减少打包后的体积：\n```js\n{\n  \"plugins\": [\n    [\"import\", { \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": \"css\" }] // `style: true` 会加载 less 文件\n  ]\n}\n```\n这个插件的功能是利用**babel**解析后得到抽象语法树，收集导入库的语句，在编译时替换为导入指定文件。\n\n以**antd**为例，以下代码做的就是根据`libraryName`，也就是**antd**，来判断，如果导入语句符合`import {Button} from 'antd'`的形式，即从**antd**导入了组件，那么就将这条语句加入到待替换列表：\n```js\nImportDeclaration(path) {\n  const { node } = path;\n\n  // path maybe removed by prev instances.\n  if (!node) return;\n\n  const { value } = node.source;\n  const libraryName = this.libraryName;\n  const types = this.types;\n  if (value === libraryName) {\n    node.specifiers.forEach(spec => {\n      if (types.isImportSpecifier(spec)) {\n        this.specified[spec.local.name] = spec.imported.name;\n      } else {\n        this.libraryObjs[spec.local.name] = true;\n      }\n    });\n    this.pathsToRemove.push(path);\n  }\n}\n```\n得到了要替换的语句，就可以根据插件中配置的选项进行替换。例如：\n```js\nimport {Button} from 'antd'\n```\n根据插件配置解析后得到的文件路径为`antd/es/button`，其中`es`是插件中的`libraryDirectory`选项，指定组件所在的源文件目录。因此，上面的语句就变成了下面的形式：\n```js\nimport Button from 'antd/es/button'\n```\n这样就不必导入整个库了。\n```js\nimportMethod(methodName, file) {\n  if (!this.selectedMethods[methodName]) {\n    const libraryDirectory = this.libraryDirectory;\n    const style = this.style;\n    const transformedMethodName = this.camel2UnderlineComponentName  // eslint-disable-line\n      ? camel2Underline(methodName)\n      : this.camel2DashComponentName\n        ? camel2Dash(methodName)\n        : methodName;\n    const path = winPath(\n      this.customName ? this.customName(transformedMethodName) : join(this.libraryName, libraryDirectory, transformedMethodName, this.fileName) // eslint-disable-line\n    );\n    this.selectedMethods[methodName] = addDefault(file.path, path, { nameHint: methodName });\n    if (style === true) {\n      addSideEffect(file.path, `${path}/style`);\n    } else if (style === 'css') {\n      addSideEffect(file.path, `${path}/style/css`);\n    } else if (typeof style === 'function') {\n      const stylePath = style(path, file);\n      if (stylePath) {\n        addSideEffect(file.path, stylePath);\n      }\n    }\n  }\n  return Object.assign({}, this.selectedMethods[methodName]);\n}\n```\n总结下来就一句话：按需加载不过是将`import {Button} from 'antd'`的形式转换为`import Button from 'antd/es/button'`的形式的过程。\n","tags":["javascript","babel"]},{"title":"算法笔记：乘2加1","url":"/2018/09/25/algo-mul2-plus1/","content":"## 问题描述\n两个数**A**和**B**，其中**A<B**。只能对**A**进行两种操作：**A=A+1** 或 **A=A*2**，求**A**到**B**的最少操作次数。\n\n## 解决思路\n先判断符号位是否相等，如果不等，就一直**A=A+1**。然后判断二进制长度是否相等，如果不等，表明数值相差较大，可以尝试**A=A*2**。如果长度相等，表明数值非常接近，直接**B-A**。\n\n## 代码实现\n```js\nfunction minStep(A, B) {\n  let step = 0\n  let bA = A.toString(2)\n  const bB = B.toString(2)\n\n  while (bA[0] !== bB[0]) {\n    step += 1\n    A = A + 1\n    bA = A.toString(2)\n  }\n  while (bA.length !== bB.length) {\n    step += 1\n    A = A << 1\n    bA = A.toString(2)\n  }\n\n  return B - A + step\n}\n```\n","tags":["javascript","algorithm"]},{"title":"JavaScript笔记(一)","url":"/2018/09/18/note-js-1/","content":"### 1. **JSONP**只能进行**GET**请求。\n### 2. `Function.prototype === Function.__proto__`, `Function.prototype`是函数。\n### 3. `jQuery.ajax`默认携带**cookie**, `axios`需要设置`withCredentials: true`才能跨域。\n","tags":["javascript","node"]},{"title":"JavaScript奇技淫巧(一)","url":"/2018/09/18/awesome-js-1/","content":"### 判断是否是数字\n```js\nfunction isNumber(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n}\n```\n判断`num - num === 0`的原因：\n1. `typeof NaN === 'number'`等于`true`、`typeof Infinity === 'number'`等于`true`。\n2. `NaN - NaN`等于`NaN`、`Infinity - Infinity`等于`NaN`。\n","tags":["javascript","node"]},{"title":"npm模块设计原则","url":"/2018/09/18/node-module-design/","content":"一个好的模块需要解决实际问题，但是能解决实际问题的模块不一定都能算得上优质的。模块也是一堆`JavaScript`代码，所以首先必须要符合`JavaScript`的代码规范，在这个前提下，才可以讨论其它原则。开发中我们会遇到各种需求，重复的多了，就会封装重复的逻辑到一个个模块中去以便多次复用。但是每个人对模块代码需要做哪些事情的认知多少有些差异，以下是个人觉得比较好的模块设计原则：\n\n## 模块功能尽量保持单一\n例如有两个需求：写一个函数判断字符串是否是回文字符串，写一个函数判断数字是否是素数。两个需求要实现的功能都不复杂，写在一个模块内也没什么不可以。但是，一个是处理字符串，一个是处理数字，如果分别写在两个模块中，很容易以后扩展。`npm`仓库中有很多这种单一的模块，例如`is-object`、`is-array`等等，因为功能单一又实用，被很多模块依赖，下载量反而比某些知名框架下载量都高。\n\n## 模块提供的函数用法尽量和Node函数风格保持一致\n不要随便命名一个函数，可以参考Node的库函数命名方式，这样使用者即使没时间看文档，也能凭经验猜出函数的用法。\n\n## 确定模块的定位，不要轻易改动\n如果模块只是要处理一个特定问题，例如将`2018/09/18 11:13:31`格式的日期字符串转换为ISO字符串`2018-09-18T03:13:31.000Z`。那么就不要再盲目增加诸如`2018-09-18 11:13:31`、`1537240411000`之类的格式处理，当使用者传递了不符合规则的参数时，直接报错是一种更好的方式。除非模块的定位本身就是处理一切日期字符串格式，比如`Moment.js`，那就是另一回事。\n\n## API尽量向下兼容\n在上一个版本中提供的API，尽量不要在下一个版本中被删除或重命名，应该给使用者留下一个过渡的时间，当使用者依然使用旧的函数时，打印警告信息告诫他不要那么做。具体做法可以参考Node的API变迁。\n\n## 与标准库函数或知名框架中同名的函数，用法尽量保持相同\n例如实现一个数组排序函数`sort(array, fn)`，这里`sort`参数中的`fn`尽量保持和传递给`Array.prototype.sort`的参数相同。\n","tags":["javascript","node"]},{"title":"npm模块学习：is-sorted","url":"/2018/09/17/npm-is-sorted/","content":"## 介绍\n**is-sorted**用来检查数字数组中的元素是否按升序或降序排序。\n\n项目地址：https://github.com/dcousens/is-sorted\n\n## 源码分析\n代码逻辑比较简单，通过遍历数组，判断当前元素与前一个元素的差值大于零或小于零，从而得出元素是否顺序排列：\n```js\nfor (var i = 1, length = array.length; i < length; ++i) {\n  if (comparator(array[i - 1], array[i]) > 0) return false\n}\n```\n`comparator`是一个比较函数，默认是按升序排列，也可以手动指定。\n```js\nfunction defaultComparator (a, b) {\n  return a - b\n}\n```\n\n## 改进\n作者直接将比较函数的结果与零比较，将范围限制的比较窄(为了和`Array.prototype.sort`参数兼容)。如果将比较操作放入比较函数内部，那我们只需要：\n```js\nfunction defaultComparator(a, b) {\n  return a - b > 0\n}\n// 然后\nif (!comparator(array[i - 1], array[i])) return false\n```\n这样写法就更灵活了，不仅能判断升序还是降序，还能判断是否按某一固定数值升降，例如：\n```js\nfunction customComparator(a, b) {\n  return a - b > 2\n}\n```\n不过这样做的一个弊端是破坏了和`Array.prototype.sort`的兼容性。\n","tags":["javascript","node","npm"]},{"title":"npm模块学习：pify","url":"/2018/09/14/npm-pify/","content":"## 介绍\n**pify**的功能和**util.promisify**一样，用来将一个函数包装为支持`Promise`的形式。\n\n项目地址：https://github.com/sindresorhus/pify\n\n## 源码分析\n将原本不支持`Promise`调用的函数转化成`Promise`风格，最简单的方法可以这么写：\n```js\nfunction promisify(f) {\n  return function () {\n    return new Promise((resolve, reject) => {\n      f.apply(this, [].slice.call(arguments).concat((err, val) => {\n        return err ? reject(err) : resolve(val)\n      }))\n    })\n  }\n}\n```\n因为对于支持错误优先的回调函数，总是这种写法，例如：\n```js\nfs.readFile('package.json', 'utf-8', (err, data) => {\n  if (err) {\n    // 处理错误\n    return\n  }\n  // 处理数据\n})\n```\n回调函数总是作为最后一个参数，所以上面我们才可以：\n```js\n[].slice.call(arguments).concat((err, val) => {\n  return err ? reject(err) : resolve(val)\n})\n```\n把`Promise`的处理逻辑追加到参数列表的末尾。\n\n**pify**库的核心代码和上面基本相同，但提供了更多的处理。例如选项：`exclude: [/.+(Sync|Stream)$/]`排除了以`Sync`和`Stream`结尾的函数名，避免了我们错误的对函数使用promisify。\n\n除了对函数名处理外，**pify**还提供对整个模块内的函数进行promisify：\n```js\nfor (const key in input) { // eslint-disable-line guard-for-in\n  const property = input[key];\n  ret[key] = typeof property === 'function' && filter(key) ? processFn(property, options) : property;\n}\n```\n其中`filter`函数过滤掉符合特定模式的函数名，使用者可以在选项中配置。\n\n另外，Node自带了`util.promisify`函数，我们不用手动去写，但是`util.promisify`不能对整个模块内的函数`promisify`。\n","tags":["javascript","node","npm"]},{"title":"npm模块学习：p-map","url":"/2018/09/13/npm-p-map/","content":"## 介绍\n**p-map**的功能是用来对一组`Promise`对象进行操作，当其中任何一个`Promise`的状态变为`fulfilled`时，执行我们传递的回调函数，只要有一个`Promise`状态变为`rejected`，所有未执行的`Promise`都不再执行。\n\n项目地址：https://github.com/sindresorhus/p-map\n\n## 源码分析\n**p-map**的代码并不复杂，以下是`p-map`的核心代码：\n```js\nconst next = () => {\n  // 如果当前Promise状态为rejected，就不再执行下一个\n  if (isRejected) {\n    return;\n  }\n\n  const nextItem = iterator.next();\n  const i = currentIndex;\n  currentIndex++;\n\n  if (nextItem.done) {\n    isIterableDone = true;\n    // 如果全部执行成功，则resolve\n    if (resolvingCount === 0) {\n      resolve(ret);\n    }\n\n    return;\n  }\n\n  resolvingCount++;\n\n  Promise.resolve(nextItem.value)\n    // 对结果进行处理\n    .then(element => mapper(element, i))\n    .then(\n      value => {\n        ret[i] = value;\n        resolvingCount--;\n        next();\n      },\n      error => {\n        isRejected = true;\n        reject(error);\n      }\n    );\n};\n```\n以上逻辑比较清晰，其中最大的亮点就是使用迭代器判断是否结束。大部分人遇到**p-map**这种需求，都会想到用`Promise.all`和`Array.prototype.map`之类的方法去实现效果。例如：\n```js\nfunction pMap(promises, mapper) {\n  return Promise.all(promises.map((item, i) => {\n    return Promise.resolve(item).then(data => mapper(data, i))\n  }))\n}\n```\n这段代码和**p-map**库的实现差别在于：即使有一个`Promise`变为`rejected`，后面的`Promise`仍然会执行，所以实际上并不能满足需求。\n\n而**p-map**中迭代器的使用不仅大大简化了实现难度，还提供了额外的控制机会，`concurrency`选项能发挥作用，也是使用迭代器带来的好处。\n","tags":["javascript","node","npm"]},{"title":"我的JavaScript命名规范","url":"/2017/04/25/api-design/","content":"## 变量\n1、普通变量采用小驼峰命名法。\n例如：`var isChar = false`、`var ok = true`\n\n2、变量私有但可以暴露给外部访问，则用单个下划线。\n例如：`var _status = false`\n\n3、变量私有且只在特定范围内有效，强烈不建议直接访问，则用双下划线。\n例如：`var __status = false`\n特殊情况下，如果变量名前后加双下划线有一定意义，那么可以用前后双下划线形式。\n例如：\n```js\nvar obj = {}\nvar __proto__ = obj.__proto__    // 此处变量前后加双下划线有特殊意义\n```\n\n4、与关键字或保留字或内置变量同名的变量用前缀符号`$`表示，并且`$`应该在下划线后。\n例如：`var $class = null`、`var __$dirname = __dirname`\n\n对于单下划线的私有变量，可以直接访问，但不能用于修改。双下划线的变量既不能直接访问更不能直接修改。\n如果需要对私有变量进行修改，必须提供`getter/setter`函数。\n例如：\n```js\nfunction A() {\n\tthis.__status = false\n\t// 提供Setter/Getter函数\n\tthis.setStatus = function (value) {\n\t\tthis.__status = value\n\t}\n\tthis.getStatus = function () {\n\t\treturn this.__status\n\t}\n}\n```\n\n## 函数\n在函数主体为空或者只有一条语句的情况下，函数可以写作一行，其它任何情况下函数都必须写成多行。\n\n### 一、参数\n1、如果某个参数是必填的，那么它应该符合小驼峰命名法。\n例如：`function clone(obj) {}`\n如果参数是引用类型，除非明确知道修改所带来的影响和结果，否则在对引用类型进行更改时，必须进行深复制，以免不当的操作所带来的结果向后传递，使错误源难以定位。\n\n2、如果某个参数是可选的，那么它应该用单个前缀下划线表示。\n例如：`function clone(obj, _isDeep) {}`\n\n3、如果某个参数需要使用`new`关键字构造，则第一个字母应该大写。\n例如：`function extend(BaseClass, properties) {}`\n\n### 二、函数名\n1、普通函数名应该符合小驼峰命名法，如果函数应该用`new`关键字构造，那么它的首字母应该大写。\n例如：`function clone(obj) {}`、`function BaseClass() {}`\n\n2、私有函数命名必须以双下划线开始同时以双下划线结束，并且私有函数不存在单下划线的情况。\n例如：`function __find__() {}`是正确的，`function _find_() {}`是错误的。\n\n### 三、参数检查规范\n对于需要传参的函数调用，除非参数符合规范命名而且唯一，例如大写开头的参数需要使用`new`构造、单下划线开头的参数是可选的。除此之外，其它类型不明确的参数，例如数字、字符串、对象都是小驼峰命名，在使用参数前，必须对参数进行类型检查。这个类型检查只针对需要使用到的参数及其值，那些传参了但未使用的参数可以忽略。如果`B`函数在`A`函数内部被调用，那么当`B`函数用到`A`的参数并且`A`也用到这个参数，则`B`不需再进行类型检查，`A`必须保证自己使用的参数传给`B`函数时依然是正确的。\n例如：\n```js\nfunction B(name, value) {\n\tthis.name = name\n\tif (typeof value !== 'number') {\n\t\tvalue = 0\n\t}\n\tthis.value = value\n}\n\nfunction A(name) {\n\tif (!(typeof name === 'string' && name !== '')) {\n\t\tname = 'A'\n\t}\n\tthis.name = name\n\tthis.b = new B(name, '123')\n}\n```\n\n## 语句\n1、声明语句\n声明语句之后必须留一空行。\n\n2、`while`和`if`语句\n如果主体只有一条语句，关键字和内容应该放在同一行，并且省略花括号。如果有多条语句，应该用花括号包裹并且以多行显示。\n在单行显示的情况下，应该始终与上条语句之间留一空行，如果在它下面的语句是声明语句，那么它与下面的语句之间也应该留一空行。如果它下面的语句不是声明语句，则空行可留可不留。如果单行的长度超过**80**个字符，那么可以选择换行，但换行后主体必须被花括号包裹。\n例如：\n```js\n// 错误\nisOk = false\n\nif (isOk) callback()\nvar result = 0        // 声明语句之后没有留空行\nif (result)           // if换行不能省略花括号\n\tisOk = true\n\n// 正确\nisOk = false\n\nif (isOk) callback()\n\nvar result = 0\n\nif (result) {\n\tisOk = true\n}\n```\n3、`for`语句\n任何情况下花括号都不省略，即使主体只有一条语句。\n\n4、`switch`语句\n主体内的`case`与`switch`关键字保持一定缩进，如果`case`的主体只有一条语句，可以写成单行形式。`default`条件是必须的，不可省略。\n\n## 代码例子\n```js\nfunction extend(_BaseClass, _properties) {\n\tvar $class = function () {\n\t\tif (Object.prototype.toString.call(this.__init__) === '[object Function]') {\n\t\t\tthis.__init__.apply(this, arguments)\n\t\t}\n\t}\n\n\tfunction BuiltinClass() {}\n\n\tif (_BaseClass) {\n\t\tBuiltinClass.prototype = _BaseClass.prototype\n\t}\n\tvar __proto__ = $class.prototype = new BuiltinClass()\n\n\tif (Object.prototype.toString.call(_properties) === '[object Object]') {\n\t\tfor (var key in _properties) {\n\t\t\tif (_properties.hasOwnProperty(key)) {\n\t\t\t\t__proto__[key] = _properties[key]\n\t\t\t}\n\t\t}\n\t}\n\t__proto__.constructor = $class\n\n\treturn $class\n}\n\nfunction Shape(_options) {\n\tthis.options = _options ? _options : {}\n}\n\nShape.prototype.getType = function () {\n\treturn this.__type\n}\n\nvar Rect = extend(Shape, {\n\t__init__: function (x, y, width, height) {\n\t\tthis.set({\n\t\t\tx: x, y: y, \n\t\t\twidth: width, height: height\n\t\t})\n\t}, \n\tset: function (properties) {\n\t\tif (Object.prototype.toString.call(properties) === '[object Object]') {\n\t\t\tfor (var key in properties) {\n\t\t\t\tif (properties.hasOwnProperty(key)) {\n\t\t\t\t\tthis[key] = properties[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, \n\t__type: 'rect'\n})\n\nvar rect = new Rect(0, 0, 300, 150)\nconsole.log(rect.x, rect.y, rect.width, rect.height, rect.getType())\n```\n","tags":["javascript"]}]